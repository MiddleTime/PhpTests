<?php
header("Content-Type: text/html;charset=utf-8");
?>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<?php


//основные операторы
// оператор присваивания "=" 
$firstName = "имя";
$lastName = "фамилия";
$fullName = $firstName . $lastName;   //оператор конкатенации 

$fullName = $firstName . " - " . $lastName;   //изменили выводы. Почему выводится только одно значение fullname?

echo $fullName;

//условные операторы
//if
/*
 * Оператор if состоит из условия и одного или нескольких операторов,
сгруппированных в виде блока. Если интерпретатор PHP оценивает выражение как истинное, 
то он выполняет блок операторов. Если условие ложно, то данный блок будет пропущен. 
В приведенном ниже примере интерпретатор PHP сравнивает значение переменных $а и $b. Если они
равны, то он выводит на экран строку «А равно B»
  
 */

echo '</br> =================================================== </br>';

$a = 5;
$b = 6;
if ($a == $b) {
echo ' A равно B';
}

echo '</br> =================================================== </br>';

//оператор else

/*
 * Оператор if дополняет оператор else, который может следовать непосредственно после него. 
 * Интерпретатор PHP выполняет код, который составляет блок оператора else, только в том случае, 
 * если пропускается выполнение оператора if. В приведенном ниже примере интерпретатор PHP сравнивает 
 * значение переменных $а и $b. Если они равны, то он выводит на экран «А равно Б», а если не равны, 
 * то выполняется код в блоке, следующем за оператором else, и на экран выводится «А не равно Б»
 */

if ($a == $b) {
echo 'A равно Б';
} else {
echo 'A не равно Б';
}

//оператор elseif

/*
 * Как следует из 
его имени, оператор elseif представляет собой сочетание операторов
if и else. Он подразумевает наличие условия, и интерпретатор PHP
проверяет это условие в том случае, если условие оператора if оказывается ложным.
Можно использовать несколько операторов elseif, чтобы проверить
различные условия, интерпретатор PHP будет проверять каждое из них,
пока одно не окажется истинным
 */
echo '</br> =================================================== </br>';

$c = 10;
$d = 5;

if ($a == $b) {
echo 'A равно B';
} elseif ($a == $c) {
echo 'A равно C';
} elseif ($a == $d) {
echo 'A равно D';
} else {
echo 'A ничему не равно';
}

echo '</br> =================================================== </br>';

// оператор SWITCH

/*
 * Если вы внимательно рассмотрите наш пример с оператором elseif,
вы заметите, что каждое условие, по сути, проверяет одно и то же — 
 * является ли значение некоторой переменной равным значению переменной $a. 
 * Оператор switch работает подобным образом, но выглядит более аккуратно
 */

switch ($a) {
case $b:
echo 'A равно B';
break;
case $c:
echo 'A равно C';
break;
case $d:
echo 'A равно D';
break;
default:
echo 'A ничему не равно';
break;
}

/*
 * В приведенном выше примере интерпретатор РНР берет значение, указанное в начале оператора switch 
 * (значение переменной $a) и сравнивает его со значением каждого оператора case. Выполняется фрагмент
    кода, содержащий соответствующее значение. Если совпадений не найдено, выполняется оператор default
 */

//ЦИКЛЫ

/*
 Циклы PHP позволяют записать один набор выражений для многократного выполнения. 
 Например, предположим, что нам нужно отобразить
числа от 1 до 100. Конечно, мы могли бы написать 100 строк кода, в каждой из которых 
использовалась бы конструкция echo для вывода следующего числа. Однако удобнее использовать цикл, 
который многократно выполняет одну конструкцию echo, но по отношению к числу, которое
каждый раз становится на единицу больше, пока не будут отображены  все 100 чисел
 */

/*
 * Цикл for — это общий механизм циклов, в котором переменная используется 
для отслеживания процесса его выполнения. Данный цикл состоит из четырех основных частей: 
инициализации переменной (установка переменной для отслеживания, или счетчика, на известное начальное
значение), 
условия (интерпретатор PHP продолжает выполнение цикла до тех пор, пока данное условие остается истинным), 
инкремента или декремента (который изменяет значение счетчика в соответствии с прогрессом цикла) 
и многократно выполняемого блока операторов.

 */

echo '<br> =================================================== <br>';

for ($i = 1; $i < 101; $i = $i + 1) {
echo $i . '<br>';
}

/*
 * Интерпретатор PHP продолжает выполнять цикл до тех пор, пока значение переменной 
 $i не достигнет 101 (что сделает условие ложным,
поскольку при этом значение переменной $i становится равно, а не
меньше 101), а затем выходит из цикла
 */

//цикл while 
/*
 * Циклы while работают почти так же, как циклы for, за исключением
того, что им требуется условие лишь в начале. Мы должны до начала
цикла установить начальное значение переменной для отслеживания,
которое будет корректироваться в блоке операторов
 */
echo '<br> =================================================== <br>';

$i = 1;
while ($i < 101){
echo $i . '<br>';
$i = $i + 1;
}

//foreach
/*
 * В отличие от циклов for и while, в которых используется конкретное
условие, цикл foreach берет переменную с несколькими ключами (например, массив) 
и применяет к каждому элементу набор операторов
 */
echo '<br> =================================================== <br>';
$myArray = array('Привет', 'Мир','родился','новый','программист');
foreach ($myArray as $value) {
echo $value . '<br>';
}

//echo $_SERVER['PHP_SELF'];